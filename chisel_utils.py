import logging
import pprint

from constants import *

# from shared_utils import overlaps, overlap_allowed, extension_overlap_allowed, instruction_overlap_allowed, process_enc_line, same_base_isa, add_segmented_vls_insn, expand_nf_field
from shared_utils import *

pp = pprint.PrettyPrinter(indent=2)
logging.basicConfig(level=logging.INFO, format="%(levelname)s:: %(message)s")


def make_chisel(instr_dict: InstrDict, spinal_hdl: bool = False):

    chisel_names = ""
    cause_names_str = ""
    csr_names_str = ""
    for i in instr_dict:
        if spinal_hdl:
            chisel_names += f'  def {i.upper().replace(".","_"):<18s} = M"b{instr_dict[i]["encoding"].replace("-","-")}"\n'
        # else:
        #     chisel_names += f'  def {i.upper().replace(".","_"):<18s} = BitPat("b{instr_dict[i]["encoding"].replace("-","?")}")\n'
    if not spinal_hdl:
        extensions = instr_dict_2_extensions(instr_dict)
        for e in extensions:
            e_instrs = filter(lambda i: instr_dict[i]["extension"][0] == e, instr_dict)
            if "rv64_" in e:
                e_format = e.replace("rv64_", "").upper() + "64"
            elif "rv32_" in e:
                e_format = e.replace("rv32_", "").upper() + "32"
            elif "rv_" in e:
                e_format = e.replace("rv_", "").upper()
            else:
                e_format = e.upper()
            chisel_names += f'  val {e_format+"Type"} = Map(\n'
            for instr in e_instrs:
                tmp_instr_name = '"' + instr.upper().replace(".", "_") + '"'
                chisel_names += f'   {tmp_instr_name:<18s} -> BitPat("b{instr_dict[instr]["encoding"].replace("-","?")}"),\n'
            chisel_names += f"  )\n"

    for num, name in causes:
        cause_names_str += f'  val {name.lower().replace(" ","_")} = {hex(num)}\n'
    cause_names_str += """  val all = {
    val res = collection.mutable.ArrayBuffer[Int]()
"""
    for num, name in causes:
        cause_names_str += f'    res += {name.lower().replace(" ","_")}\n'
    cause_names_str += """    res.toArray
  }"""

    for num, name in csrs + csrs32:
        csr_names_str += f"  val {name} = {hex(num)}\n"
    csr_names_str += """  val all = {
    val res = collection.mutable.ArrayBuffer[Int]()
"""
    for num, name in csrs:
        csr_names_str += f"""    res += {name}\n"""
    csr_names_str += """    res.toArray
  }
  val all32 = {
    val res = collection.mutable.ArrayBuffer(all:_*)
"""
    for num, name in csrs32:
        csr_names_str += f"""    res += {name}\n"""
    csr_names_str += """    res.toArray
  }"""

    if spinal_hdl:
        chisel_file = open("inst.spinalhdl", "w")
    else:
        chisel_file = open("inst.chisel", "w")
    chisel_file.write(
        f"""
/* Automatically generated by parse_opcodes */
object Instructions {{
{chisel_names}
}}
object Causes {{
{cause_names_str}
}}
object CSRs {{
{csr_names_str}
}}
"""
    )
    chisel_file.close()
